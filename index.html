<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Data Stories: Interactive Music Analytics</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .story {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 40px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .story:hover {
            transform: translateY(-5px);
        }

        .story-title {
            font-size: 2.2rem;
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }

        .story-description {
            font-size: 1.1rem;
            color: #666;
            margin-bottom: 30px;
            text-align: center;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .viz-container {
            display: grid;
            gap: 30px;
            margin-bottom: 30px;
        }

        .viz-container.three-col {
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        }

        .viz-container.two-col {
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
        }

        .viz-item {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .viz-title {
            font-size: 1.3rem;
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }

        .chart-container {
            min-height: 300px;
            position: relative;
        }

        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(0,0,0,0.9);
            color: white;
            border-radius: 6px;
            pointer-events: none;
            font-size: 14px;
            max-width: 250px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .axis {
            font-size: 12px;
        }

        .axis text {
            fill: #666;
        }

        .axis line, .axis path {
            fill: none;
            stroke: #ddd;
            shape-rendering: crispEdges;
        }

        .grid line {
            stroke: #eee;
            stroke-dasharray: 2,2;
        }

        .grid path {
            stroke-width: 0;
        }

        .bar {
            transition: opacity 0.3s ease;
        }

        .bar:hover {
            opacity: 0.8;
        }

        .line {
            fill: none;
            stroke-width: 3;
        }

        .dot {
            stroke: white;
            stroke-width: 2;
            transition: r 0.3s ease;
        }

        .dot:hover {
            r: 8;
        }

        .insights {
            background: #e8f4fd;
            border-left: 4px solid #3498db;
            padding: 20px;
            margin-top: 20px;
            border-radius: 0 8px 8px 0;
        }

        .insights h4 {
            color: #2980b9;
            margin-bottom: 10px;
        }

        .insights ul {
            color: #34495e;
            padding-left: 20px;
        }

        .insights li {
            margin-bottom: 5px;
        }

        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .controls {
            text-align: center;
            margin-bottom: 20px;
        }

        .controls select {
            padding: 8px 15px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            background: white;
        }

        @media (max-width: 768px) {
            .viz-container.three-col,
            .viz-container.two-col {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .story {
                padding: 20px;
            }
        }

        .radar-chart {
            text-align: center;
        }

        .radar-area {
            fill-opacity: 0.3;
            stroke-width: 2;
        }

        .radar-stroke {
            fill: none;
            stroke-width: 3;
        }

        .radar-circle {
            fill: none;
            stroke: #ddd;
            stroke-width: 1;
        }

        .radar-line {
            stroke: #ddd;
            stroke-width: 1;
        }

        .radar-label {
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéµ Spotify Data Stories</h1>
            <p>Interactive Analytics of 500 Curated Tracks Across 15 Genres</p>
        </div>

        <!-- Story 1: The Loudness Wars -->
        <div class="story">
            <h2 class="story-title">üîä Story 1: The Loudness Wars</h2>
            <p class="story-description">
                The "loudness wars" refer to the trend of increasing audio loudness in recorded music. 
                Let's explore how loudness affects popularity and varies across genres in our dataset.
            </p>
            
            <div class="viz-container three-col">
                <div class="viz-item">
                    <h3 class="viz-title">Popularity by Loudness Deciles</h3>
                    <div class="chart-container" id="loudness-popularity-chart"></div>
                </div>
                
                <div class="viz-item">
                    <h3 class="viz-title">Top 15 Loudest Genres</h3>
                    <div class="chart-container" id="loudest-genres-chart"></div>
                </div>
                
                <div class="viz-item">
                    <h3 class="viz-title">Loudness vs Energy</h3>
                    <div class="chart-container" id="loudness-energy-chart"></div>
                </div>
            </div>
            
            <div class="insights">
                <h4>Key Insights:</h4>
                <ul>
                    <li>Moderate loudness levels (-8 to -4 dB) show the highest popularity scores</li>
                    <li>Electronic genres like minimal-techno and progressive-house dominate the loudness charts</li>
                    <li>There's a strong positive correlation between loudness and energy across tracks</li>
                    <li>Very quiet tracks tend to have lower mainstream appeal</li>
                </ul>
            </div>
        </div>

        <!-- Story 2: Artist Uniqueness Analysis -->
        <div class="story">
            <h2 class="story-title">üé® Story 2: Artist Uniqueness Analysis</h2>
            <p class="story-description">
                Some artists develop distinctive sonic signatures that set them apart. We calculate uniqueness 
                scores based on how far each artist's audio features deviate from the dataset average.
            </p>
            
            <div class="viz-container two-col">
                <div class="viz-item">
                    <h3 class="viz-title">Top 15 Most Unique Artists</h3>
                    <div class="chart-container" id="unique-artists-chart"></div>
                </div>
                
                <div class="viz-item">
                    <h3 class="viz-title">Artist Audio DNA Comparison</h3>
                    <div class="controls">
                        <select id="artist-selector">
                            <option value="">Select an artist to compare...</option>
                        </select>
                    </div>
                    <div class="chart-container" id="artist-radar-chart"></div>
                </div>
            </div>
            
            <div class="insights">
                <h4>Key Insights:</h4>
                <ul>
                    <li>Artists with high instrumentalness and acousticness tend to be most unique</li>
                    <li>Pop and mainstream artists cluster closer to the dataset average</li>
                    <li>New-age and ambient artists show the most distinctive audio fingerprints</li>
                    <li>Uniqueness doesn't always correlate with popularity - some unique artists have niche appeal</li>
                </ul>
            </div>
        </div>

        <!-- Story 3: The 3-Minute Rule -->
        <div class="story">
            <h2 class="story-title">‚è±Ô∏è Story 3: The 3-Minute Rule</h2>
            <p class="story-description">
                The "3-minute rule" suggests that radio-friendly songs should be around 3 minutes long. 
                Let's examine how song duration relates to popularity and varies across genres.
            </p>
            
            <div class="viz-container three-col">
                <div class="viz-item">
                    <h3 class="viz-title">Popularity by Duration Bins</h3>
                    <div class="chart-container" id="duration-popularity-chart"></div>
                </div>
                
                <div class="viz-item">
                    <h3 class="viz-title">Song Duration Distribution</h3>
                    <div class="chart-container" id="duration-histogram-chart"></div>
                </div>
                
                <div class="viz-item">
                    <h3 class="viz-title">Average Duration by Genre</h3>
                    <div class="chart-container" id="genre-duration-chart"></div>
                </div>
            </div>
            
            <div class="insights">
                <h4>Key Insights:</h4>
                <ul>
                    <li>Songs between 3-3.5 minutes achieve the highest average popularity</li>
                    <li>The sweet spot for radio play appears to be right around the traditional 3-minute mark</li>
                    <li>Progressive and new-age genres favor longer compositions</li>
                    <li>Very short songs (&lt;2 minutes) and very long songs (&gt;5 minutes) tend to have lower popularity</li>
                </ul>
            </div>
        </div>

        <!-- Story 4: Explicit Content Impact -->
        <div class="story">
            <h2 class="story-title">üö´ Story 4: Explicit Content Impact</h2>
            <p class="story-description">
                How does explicit content affect a song's characteristics and popularity? 
                We'll compare explicit and clean tracks across various dimensions.
            </p>
            
            <div class="viz-container three-col">
                <div class="viz-item">
                    <h3 class="viz-title">Popularity: Explicit vs Clean</h3>
                    <div class="chart-container" id="explicit-popularity-chart"></div>
                </div>
                
                <div class="viz-item">
                    <h3 class="viz-title">Explicit Content by Genre</h3>
                    <div class="chart-container" id="explicit-genre-chart"></div>
                </div>
                
                <div class="viz-item">
                    <h3 class="viz-title">Audio Features Comparison</h3>
                    <div class="chart-container" id="explicit-features-chart"></div>
                </div>
            </div>
            
            <div class="insights">
                <h4>Key Insights:</h4>
                <ul>
                    <li>Explicit tracks show slightly higher popularity on average</li>
                    <li>Hip-hop and rap genres have the highest percentage of explicit content</li>
                    <li>Explicit tracks tend to have higher speechiness and energy levels</li>
                    <li>Clean tracks show higher valence (positivity) scores on average</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Load the sample data
        let spotifyData = [];
        
        // Load data from the JSON file
        fetch('./sampling/sample_data.json')
            .then(response => response.json())
            .then(data => {
                spotifyData = data;
                initializeVisualizations();
            })
            .catch(error => {
                console.error('Error loading data:', error);
                // Fallback to embedded sample data
                spotifyData = [
                    {"track_id":"sample1","artists":"Sample Artist","track_name":"Sample Song","track_genre":"pop","popularity":50,"duration_min":3.5,"explicit":false,"danceability":0.6,"energy":0.7,"loudness":-8,"speechiness":0.05,"acousticness":0.2,"instrumentalness":0.01,"liveness":0.1,"valence":0.6,"tempo":120}
                ];
                initializeVisualizations();
            });

        function initializeVisualizations() {
            createLoudnessPopularityChart();
            createLoudestGenresChart();
            createLoudnessEnergyChart();
            createUniqueArtistsChart();
            createArtistRadarChart();
            createDurationPopularityChart();
            createDurationHistogram();
            createGenreDurationChart();
            createExplicitPopularityChart();
            createExplicitGenreChart();
            createExplicitFeaturesChart();
        }

        // Color schemes
        const colors = {
            primary: '#3498db',
            secondary: '#e74c3c',
            accent: '#f39c12',
            success: '#27ae60',
            info: '#9b59b6',
            gradient: ['#667eea', '#764ba2', '#f093fb', '#4facfe', '#00f2fe', '#43e97b']
        };

        // Utility functions
        function createTooltip() {
            return d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);
        }

        function showTooltip(tooltip, content, event) {
            tooltip.transition().duration(200).style('opacity', .9);
            tooltip.html(content)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 28) + 'px');
        }

        function hideTooltip(tooltip) {
            tooltip.transition().duration(500).style('opacity', 0);
        }

        // Story 1: Loudness Wars Charts
        function createLoudnessPopularityChart() {
            const container = d3.select('#loudness-popularity-chart');
            const margin = {top: 20, right: 30, bottom: 40, left: 50};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Create loudness deciles
            const loudnessExtent = d3.extent(spotifyData, d => d.loudness);
            const deciles = d3.range(10).map(i => {
                const min = loudnessExtent[0] + (loudnessExtent[1] - loudnessExtent[0]) * i / 10;
                const max = loudnessExtent[0] + (loudnessExtent[1] - loudnessExtent[0]) * (i + 1) / 10;
                const tracks = spotifyData.filter(d => d.loudness >= min && d.loudness < max);
                return {
                    decile: i + 1,
                    loudnessRange: `${min.toFixed(1)} to ${max.toFixed(1)} dB`,
                    avgPopularity: d3.mean(tracks, d => d.popularity) || 0,
                    count: tracks.length
                };
            });

            const x = d3.scaleBand()
                .domain(deciles.map(d => d.decile))
                .range([0, width])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, d3.max(deciles, d => d.avgPopularity)])
                .range([height, 0]);

            const tooltip = createTooltip();

            // Add bars
            svg.selectAll('.bar')
                .data(deciles)
                .enter().append('rect')
                .attr('class', 'bar')
                .attr('x', d => x(d.decile))
                .attr('width', x.bandwidth())
                .attr('y', d => y(d.avgPopularity))
                .attr('height', d => height - y(d.avgPopularity))
                .attr('fill', colors.primary)
                .on('mouseover', function(event, d) {
                    showTooltip(tooltip, `
                        <strong>Decile ${d.decile}</strong><br/>
                        Loudness: ${d.loudnessRange}<br/>
                        Avg Popularity: ${d.avgPopularity.toFixed(1)}<br/>
                        Tracks: ${d.count}
                    `, event);
                })
                .on('mouseout', () => hideTooltip(tooltip));

            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 35)
                .attr('fill', 'black')
                .style('text-anchor', 'middle')
                .text('Loudness Decile');

            svg.append('g')
                .call(d3.axisLeft(y))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -35)
                .attr('x', -height / 2)
                .attr('fill', 'black')
                .style('text-anchor', 'middle')
                .text('Average Popularity');
        }

        function createLoudestGenresChart() {
            const container = d3.select('#loudest-genres-chart');
            const margin = {top: 20, right: 30, bottom: 100, left: 80};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Calculate average loudness by genre
            const genreLoudness = d3.rollup(spotifyData, 
                v => d3.mean(v, d => d.loudness),
                d => d.track_genre
            );

            const data = Array.from(genreLoudness, ([genre, loudness]) => ({genre, loudness}))
                .sort((a, b) => b.loudness - a.loudness)
                .slice(0, 15);

            const x = d3.scaleLinear()
                .domain([d3.min(data, d => d.loudness) - 1, d3.max(data, d => d.loudness) + 1])
                .range([0, width]);

            const y = d3.scaleBand()
                .domain(data.map(d => d.genre))
                .range([0, height])
                .padding(0.1);

            const tooltip = createTooltip();

            // Add bars
            svg.selectAll('.bar')
                .data(data)
                .enter().append('rect')
                .attr('class', 'bar')
                .attr('x', x(0))
                .attr('y', d => y(d.genre))
                .attr('width', d => Math.abs(x(d.loudness) - x(0)))
                .attr('height', y.bandwidth())
                .attr('fill', colors.secondary)
                .on('mouseover', function(event, d) {
                    showTooltip(tooltip, `
                        <strong>${d.genre}</strong><br/>
                        Avg Loudness: ${d.loudness.toFixed(2)} dB
                    `, event);
                })
                .on('mouseout', () => hideTooltip(tooltip));

            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 35)
                .attr('fill', 'black')
                .style('text-anchor', 'middle')
                .text('Average Loudness (dB)');

            svg.append('g')
                .call(d3.axisLeft(y))
                .selectAll('text')
                .style('font-size', '11px');
        }

        function createLoudnessEnergyChart() {
            const container = d3.select('#loudness-energy-chart');
            const margin = {top: 20, right: 30, bottom: 40, left: 50};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const x = d3.scaleLinear()
                .domain(d3.extent(spotifyData, d => d.loudness))
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([0, 1])
                .range([height, 0]);

            const colorScale = d3.scaleSequential(d3.interpolateViridis)
                .domain(d3.extent(spotifyData, d => d.popularity));

            const tooltip = createTooltip();

            // Add dots
            svg.selectAll('.dot')
                .data(spotifyData)
                .enter().append('circle')
                .attr('class', 'dot')
                .attr('cx', d => x(d.loudness))
                .attr('cy', d => y(d.energy))
                .attr('r', 4)
                .attr('fill', d => colorScale(d.popularity))
                .on('mouseover', function(event, d) {
                    showTooltip(tooltip, `
                        <strong>${d.track_name}</strong><br/>
                        Artist: ${d.artists}<br/>
                        Loudness: ${d.loudness.toFixed(2)} dB<br/>
                        Energy: ${d.energy.toFixed(3)}<br/>
                        Popularity: ${d.popularity}
                    `, event);
                })
                .on('mouseout', () => hideTooltip(tooltip));

            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 35)
                .attr('fill', 'black')
                .style('text-anchor', 'middle')
                .text('Loudness (dB)');

            svg.append('g')
                .call(d3.axisLeft(y))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -35)
                .attr('x', -height / 2)
                .attr('fill', 'black')
                .style('text-anchor', 'middle')
                .text('Energy');

            // Add color legend
            const legendWidth = 200;
            const legendHeight = 10;
            const legend = svg.append('g')
                .attr('transform', `translate(${width - legendWidth - 20}, 20)`);

            const legendScale = d3.scaleLinear()
                .domain(d3.extent(spotifyData, d => d.popularity))
                .range([0, legendWidth]);

            const legendAxis = d3.axisBottom(legendScale)
                .ticks(5);

            legend.append('defs')
                .append('linearGradient')
                .attr('id', 'legend-gradient')
                .selectAll('stop')
                .data(d3.range(0, 1.1, 0.1))
                .enter().append('stop')
                .attr('offset', d => d * 100 + '%')
                .attr('stop-color', d => d3.interpolateViridis(d));

            legend.append('rect')
                .attr('width', legendWidth)
                .attr('height', legendHeight)
                .style('fill', 'url(#legend-gradient)');

            legend.append('g')
                .attr('transform', `translate(0, ${legendHeight})`)
                .call(legendAxis)
                .append('text')
                .attr('x', legendWidth / 2)
                .attr('y', 25)
                .attr('fill', 'black')
                .style('text-anchor', 'middle')
                .style('font-size', '12px')
                .text('Popularity');
        }

        // Story 2: Artist Uniqueness Charts
        function createUniqueArtistsChart() {
            const container = d3.select('#unique-artists-chart');
            const margin = {top: 20, right: 30, bottom: 40, left: 150};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Calculate uniqueness scores
            const features = ['danceability', 'energy', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence'];
            const avgFeatures = {};
            features.forEach(feature => {
                avgFeatures[feature] = d3.mean(spotifyData, d => d[feature]);
            });

            const artistUniqueness = d3.rollup(spotifyData, tracks => {
                const artistAvg = {};
                features.forEach(feature => {
                    artistAvg[feature] = d3.mean(tracks, d => d[feature]);
                });
                
                // Calculate Euclidean distance from dataset average
                const distance = Math.sqrt(
                    features.reduce((sum, feature) => {
                        return sum + Math.pow(artistAvg[feature] - avgFeatures[feature], 2);
                    }, 0)
                );
                
                return {
                    uniqueness: distance,
                    trackCount: tracks.length,
                    avgPopularity: d3.mean(tracks, d => d.popularity)
                };
            }, d => d.artists);

            const data = Array.from(artistUniqueness, ([artist, stats]) => ({
                artist,
                ...stats
            }))
                .filter(d => d.trackCount >= 2) // Only artists with 2+ tracks
                .sort((a, b) => b.uniqueness - a.uniqueness)
                .slice(0, 15);

            const x = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.uniqueness)])
                .range([0, width]);

            const y = d3.scaleBand()
                .domain(data.map(d => d.artist))
                .range([0, height])
                .padding(0.1);

            const tooltip = createTooltip();

            // Add bars
            svg.selectAll('.bar')
                .data(data)
                .enter().append('rect')
                .attr('class', 'bar')
                .attr('x', 0)
                .attr('y', d => y(d.artist))
                .attr('width', d => x(d.uniqueness))
                .attr('height', y.bandwidth())
                .attr('fill', colors.accent)
                .on('mouseover', function(event, d) {
                    showTooltip(tooltip, `
                        <strong>${d.artist}</strong><br/>
                        Uniqueness Score: ${d.uniqueness.toFixed(3)}<br/>
                        Tracks: ${d.trackCount}<br/>
                        Avg Popularity: ${d.avgPopularity.toFixed(1)}
                    `, event);
                })
                .on('mouseout', () => hideTooltip(tooltip))
                .on('click', function(event, d) {
                    // Update radar chart
                    d3.select('#artist-selector').property('value', d.artist);
                    updateRadarChart(d.artist);
                });

            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 35)
                .attr('fill', 'black')
                .style('text-anchor', 'middle')
                .text('Uniqueness Score');

            svg.append('g')
                .call(d3.axisLeft(y))
                .selectAll('text')
                .style('font-size', '11px');

            // Populate artist selector
            const artistOptions = Array.from(new Set(spotifyData.map(d => d.artists)))
                .sort();
            
            const selector = d3.select('#artist-selector');
            selector.selectAll('option')
                .data(artistOptions)
                .enter().append('option')
                .attr('value', d => d)
                .text(d => d);
        }

        function createArtistRadarChart() {
            // This will be implemented when an artist is selected
            const container = d3.select('#artist-radar-chart');
            container.append('div')
                .style('text-align', 'center')
                .style('padding', '50px')
                .style('color', '#666')
                .text('Select an artist from the dropdown above to see their audio DNA profile');
        }

        function updateRadarChart(selectedArtist) {
            const container = d3.select('#artist-radar-chart');
            container.selectAll('*').remove();

            const margin = 40;
            const width = container.node().getBoundingClientRect().width - margin * 2;
            const height = 300 - margin * 2;
            const radius = Math.min(width, height) / 2;

            const svg = container.append('svg')
                .attr('width', width + margin * 2)
                .attr('height', height + margin * 2)
                .append('g')
                .attr('transform', `translate(${width/2 + margin},${height/2 + margin})`);

            const features = ['danceability', 'energy', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence'];
            
            // Calculate dataset average
            const datasetAvg = features.map(feature => ({
                feature,
                value: d3.mean(spotifyData, d => d[feature])
            }));

            // Calculate artist average
            const artistTracks = spotifyData.filter(d => d.artists === selectedArtist);
            const artistAvg = features.map(feature => ({
                feature,
                value: d3.mean(artistTracks, d => d[feature])
            }));

            const angleSlice = Math.PI * 2 / features.length;

            // Create scales
            const rScale = d3.scaleLinear()
                .range([0, radius])
                .domain([0, 1]);

            // Create radar grid
            const levels = 5;
            for (let level = 1; level <= levels; level++) {
                svg.append('circle')
                    .attr('class', 'radar-circle')
                    .attr('r', radius * level / levels)
                    .style('fill', 'none')
                    .style('stroke', '#ddd')
                    .style('stroke-width', 1);
            }

            // Create axis lines
            features.forEach((feature, i) => {
                const angle = angleSlice * i - Math.PI / 2;
                svg.append('line')
                    .attr('class', 'radar-line')
                    .attr('x1', 0)
                    .attr('y1', 0)
                    .attr('x2', radius * Math.cos(angle))
                    .attr('y2', radius * Math.sin(angle))
                    .style('stroke', '#ddd')
                    .style('stroke-width', 1);

                // Add labels
                svg.append('text')
                    .attr('class', 'radar-label')
                    .attr('x', (radius + 15) * Math.cos(angle))
                    .attr('y', (radius + 15) * Math.sin(angle))
                    .style('text-anchor', 'middle')
                    .style('dominant-baseline', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .text(feature);
            });

            // Create radar areas
            function createRadarArea(data, color, opacity) {
                const line = d3.lineRadial()
                    .angle((d, i) => angleSlice * i)
                    .radius(d => rScale(d.value))
                    .curve(d3.curveLinearClosed);

                svg.append('path')
                    .datum(data)
                    .attr('class', 'radar-area')
                    .attr('d', line)
                    .style('fill', color)
                    .style('fill-opacity', opacity)
                    .style('stroke', color)
                    .style('stroke-width', 2);

                // Add dots
                svg.selectAll('.radar-dot-' + color.replace('#', ''))
                    .data(data)
                    .enter().append('circle')
                    .attr('class', 'radar-dot-' + color.replace('#', ''))
                    .attr('cx', (d, i) => rScale(d.value) * Math.cos(angleSlice * i - Math.PI / 2))
                    .attr('cy', (d, i) => rScale(d.value) * Math.sin(angleSlice * i - Math.PI / 2))
                    .attr('r', 4)
                    .style('fill', color)
                    .style('stroke', 'white')
                    .style('stroke-width', 2);
            }

            createRadarArea(datasetAvg, colors.primary, 0.3);
            createRadarArea(artistAvg, colors.secondary, 0.3);

            // Add legend
            const legend = container.append('div')
                .attr('class', 'legend')
                .style('margin-top', '20px');

            legend.append('div')
                .attr('class', 'legend-item')
                .html(`<div class="legend-color" style="background: ${colors.primary};"></div> Dataset Average`);

            legend.append('div')
                .attr('class', 'legend-item')
                .html(`<div class="legend-color" style="background: ${colors.secondary};"></div> ${selectedArtist}`);
        }

        // Story 3: Duration Charts
        function createDurationPopularityChart() {
            const container = d3.select('#duration-popularity-chart');
            const margin = {top: 20, right: 30, bottom: 60, left: 50};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Create duration bins
            const bins = [
                { label: '<2min', min: 0, max: 2 },
                { label: '2-2.5min', min: 2, max: 2.5 },
                { label: '2.5-3min', min: 2.5, max: 3 },
                { label: '3-3.5min', min: 3, max: 3.5 },
                { label: '3.5-4min', min: 3.5, max: 4 },
                { label: '4-5min', min: 4, max: 5 },
                { label: '>5min', min: 5, max: Infinity }
            ];

            const binData = bins.map(bin => {
                const tracks = spotifyData.filter(d => d.duration_min >= bin.min && d.duration_min < bin.max);
                return {
                    ...bin,
                    avgPopularity: d3.mean(tracks, d => d.popularity) || 0,
                    count: tracks.length
                };
            });

            const x = d3.scaleBand()
                .domain(binData.map(d => d.label))
                .range([0, width])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, d3.max(binData, d => d.avgPopularity)])
                .range([height, 0]);

            const tooltip = createTooltip();

            // Add bars
            svg.selectAll('.bar')
                .data(binData)
                .enter().append('rect')
                .attr('class', 'bar')
                .attr('x', d => x(d.label))
                .attr('width', x.bandwidth())
                .attr('y', d => y(d.avgPopularity))
                .attr('height', d => height - y(d.avgPopularity))
                .attr('fill', colors.success)
                .on('mouseover', function(event, d) {
                    showTooltip(tooltip, `
                        <strong>${d.label}</strong><br/>
                        Avg Popularity: ${d.avgPopularity.toFixed(1)}<br/>
                        Tracks: ${d.count}
                    `, event);
                })
                .on('mouseout', () => hideTooltip(tooltip));

            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-45)');

            svg.append('g')
                .call(d3.axisLeft(y))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -35)
                .attr('x', -height / 2)
                .attr('fill', 'black')
                .style('text-anchor', 'middle')
                .text('Average Popularity');
        }

        function createDurationHistogram() {
            const container = d3.select('#duration-histogram-chart');
            const margin = {top: 20, right: 30, bottom: 40, left: 50};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const x = d3.scaleLinear()
                .domain(d3.extent(spotifyData, d => d.duration_min))
                .range([0, width]);

            const histogram = d3.histogram()
                .value(d => d.duration_min)
                .domain(x.domain())
                .thresholds(x.ticks(20));

            const bins = histogram(spotifyData);

            const y = d3.scaleLinear()
                .domain([0, d3.max(bins, d => d.length)])
                .range([height, 0]);

            const tooltip = createTooltip();

            // Add bars
            svg.selectAll('rect')
                .data(bins)
                .enter().append('rect')
                .attr('x', d => x(d.x0))
                .attr('width', d => Math.max(0, x(d.x1) - x(d.x0) - 1))
                .attr('y', d => y(d.length))
                .attr('height', d => height - y(d.length))
                .attr('fill', colors.info)
                .on('mouseover', function(event, d) {
                    showTooltip(tooltip, `
                        <strong>${d.x0.toFixed(1)} - ${d.x1.toFixed(1)} min</strong><br/>
                        Tracks: ${d.length}
                    `, event);
                })
                .on('mouseout', () => hideTooltip(tooltip));

            // Add 3-minute line
            svg.append('line')
                .attr('x1', x(3))
                .attr('x2', x(3))
                .attr('y1', 0)
                .attr('y2', height)
                .attr('stroke', colors.secondary)
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5');

            svg.append('text')
                .attr('x', x(3) + 5)
                .attr('y', 15)
                .attr('fill', colors.secondary)
                .style('font-size', '12px')
                .text('3-minute mark');

            // Add median line
            const median = d3.median(spotifyData, d => d.duration_min);
            svg.append('line')
                .attr('x1', x(median))
                .attr('x2', x(median))
                .attr('y1', 0)
                .attr('y2', height)
                .attr('stroke', colors.accent)
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '3,3');

            svg.append('text')
                .attr('x', x(median) + 5)
                .attr('y', 35)
                .attr('fill', colors.accent)
                .style('font-size', '12px')
                .text(`Median (${median.toFixed(1)}min)`);

            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 35)
                .attr('fill', 'black')
                .style('text-anchor', 'middle')
                .text('Duration (minutes)');

            svg.append('g')
                .call(d3.axisLeft(y))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -35)
                .attr('x', -height / 2)
                .attr('fill', 'black')
                .style('text-anchor', 'middle')
                .text('Number of Tracks');
        }

        function createGenreDurationChart() {
            const container = d3.select('#genre-duration-chart');
            const margin = {top: 20, right: 30, bottom: 100, left: 80};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Calculate average duration by genre
            const genreDuration = d3.rollup(spotifyData, 
                v => d3.mean(v, d => d.duration_min),
                d => d.track_genre
            );

            const data = Array.from(genreDuration, ([genre, duration]) => ({genre, duration}))
                .sort((a, b) => b.duration - a.duration)
                .slice(0, 10);

            const x = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.duration)])
                .range([0, width]);

            const y = d3.scaleBand()
                .domain(data.map(d => d.genre))
                .range([0, height])
                .padding(0.1);

            const tooltip = createTooltip();

            // Add bars
            svg.selectAll('.bar')
                .data(data)
                .enter().append('rect')
                .attr('class', 'bar')
                .attr('x', 0)
                .attr('y', d => y(d.genre))
                .attr('width', d => x(d.duration))
                .attr('height', y.bandwidth())
                .attr('fill', d => colors.gradient[Math.floor(Math.random() * colors.gradient.length)])
                .on('mouseover', function(event, d) {
                    showTooltip(tooltip, `
                        <strong>${d.genre}</strong><br/>
                        Avg Duration: ${d.duration.toFixed(2)} minutes
                    `, event);
                })
                .on('mouseout', () => hideTooltip(tooltip));

            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 35)
                .attr('fill', 'black')
                .style('text-anchor', 'middle')
                .text('Average Duration (minutes)');

            svg.append('g')
                .call(d3.axisLeft(y))
                .selectAll('text')
                .style('font-size', '11px');
        }

        // Story 4: Explicit Content Charts
        function createExplicitPopularityChart() {
            const container = d3.select('#explicit-popularity-chart');
            const margin = {top: 20, right: 30, bottom: 40, left: 50};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Calculate statistics
            const explicitTracks = spotifyData.filter(d => d.explicit);
            const cleanTracks = spotifyData.filter(d => !d.explicit);
            
            const explicitPop = d3.mean(explicitTracks, d => d.popularity);
            const cleanPop = d3.mean(cleanTracks, d => d.popularity);
            
            const explicitStd = d3.deviation(explicitTracks, d => d.popularity);
            const cleanStd = d3.deviation(cleanTracks, d => d.popularity);

            // Perform t-test (simplified)
            const n1 = explicitTracks.length;
            const n2 = cleanTracks.length;
            const pooledStd = Math.sqrt(((n1 - 1) * explicitStd * explicitStd + (n2 - 1) * cleanStd * cleanStd) / (n1 + n2 - 2));
            const tStat = Math.abs(explicitPop - cleanPop) / (pooledStd * Math.sqrt(1/n1 + 1/n2));
            const significant = tStat > 1.96; // Approximate 95% confidence

            const data = [
                { type: 'Explicit', popularity: explicitPop, std: explicitStd, count: n1 },
                { type: 'Clean', popularity: cleanPop, std: cleanStd, count: n2 }
            ];

            const x = d3.scaleBand()
                .domain(data.map(d => d.type))
                .range([0, width])
                .padding(0.3);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.popularity + d.std)])
                .range([height, 0]);

            const tooltip = createTooltip();

            // Add bars
            svg.selectAll('.bar')
                .data(data)
                .enter().append('rect')
                .attr('class', 'bar')
                .attr('x', d => x(d.type))
                .attr('width', x.bandwidth())
                .attr('y', d => y(d.popularity))
                .attr('height', d => height - y(d.popularity))
                .attr('fill', d => d.type === 'Explicit' ? colors.secondary : colors.primary)
                .on('mouseover', function(event, d) {
                    showTooltip(tooltip, `
                        <strong>${d.type} Tracks</strong><br/>
                        Avg Popularity: ${d.popularity.toFixed(1)}<br/>
                        Standard Deviation: ${d.std.toFixed(1)}<br/>
                        Count: ${d.count}
                    `, event);
                })
                .on('mouseout', () => hideTooltip(tooltip));

            // Add error bars
            svg.selectAll('.error-bar')
                .data(data)
                .enter().append('line')
                .attr('class', 'error-bar')
                .attr('x1', d => x(d.type) + x.bandwidth() / 2)
                .attr('x2', d => x(d.type) + x.bandwidth() / 2)
                .attr('y1', d => y(d.popularity - d.std))
                .attr('y2', d => y(d.popularity + d.std))
                .attr('stroke', 'black')
                .attr('stroke-width', 2);

            // Add caps to error bars
            svg.selectAll('.error-cap-top')
                .data(data)
                .enter().append('line')
                .attr('class', 'error-cap-top')
                .attr('x1', d => x(d.type) + x.bandwidth() / 2 - 10)
                .attr('x2', d => x(d.type) + x.bandwidth() / 2 + 10)
                .attr('y1', d => y(d.popularity + d.std))
                .attr('y2', d => y(d.popularity + d.std))
                .attr('stroke', 'black')
                .attr('stroke-width', 2);

            svg.selectAll('.error-cap-bottom')
                .data(data)
                .enter().append('line')
                .attr('class', 'error-cap-bottom')
                .attr('x1', d => x(d.type) + x.bandwidth() / 2 - 10)
                .attr('x2', d => x(d.type) + x.bandwidth() / 2 + 10)
                .attr('y1', d => y(d.popularity - d.std))
                .attr('y2', d => y(d.popularity - d.std))
                .attr('stroke', 'black')
                .attr('stroke-width', 2);

            // Add significance indicator
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', -5)
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .attr('fill', significant ? colors.success : colors.secondary)
                .text(significant ? '‚òÖ Statistically Significant' : 'Not Statistically Significant');

            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x));

            svg.append('g')
                .call(d3.axisLeft(y))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -35)
                .attr('x', -height / 2)
                .attr('fill', 'black')
                .style('text-anchor', 'middle')
                .text('Average Popularity');
        }

        function createExplicitGenreChart() {
            const container = d3.select('#explicit-genre-chart');
            const margin = {top: 20, right: 30, bottom: 100, left: 80};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Calculate explicit percentage by genre
            const genreExplicit = d3.rollup(spotifyData, tracks => {
                const explicitCount = tracks.filter(d => d.explicit).length;
                return {
                    percentage: (explicitCount / tracks.length) * 100,
                    explicitCount,
                    totalCount: tracks.length
                };
            }, d => d.track_genre);

            const data = Array.from(genreExplicit, ([genre, stats]) => ({
                genre,
                ...stats
            }))
                .filter(d => d.totalCount >= 5) // Only genres with 5+ tracks
                .sort((a, b) => b.percentage - a.percentage)
                .slice(0, 15);

            const x = d3.scaleLinear()
                .domain([0, 100])
                .range([0, width]);

            const y = d3.scaleBand()
                .domain(data.map(d => d.genre))
                .range([0, height])
                .padding(0.1);

            const tooltip = createTooltip();

            // Add bars
            svg.selectAll('.bar')
                .data(data)
                .enter().append('rect')
                .attr('class', 'bar')
                .attr('x', 0)
                .attr('y', d => y(d.genre))
                .attr('width', d => x(d.percentage))
                .attr('height', y.bandwidth())
                .attr('fill', colors.accent)
                .on('mouseover', function(event, d) {
                    showTooltip(tooltip, `
                        <strong>${d.genre}</strong><br/>
                        Explicit: ${d.percentage.toFixed(1)}%<br/>
                        (${d.explicitCount}/${d.totalCount} tracks)
                    `, event);
                })
                .on('mouseout', () => hideTooltip(tooltip));

            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 35)
                .attr('fill', 'black')
                .style('text-anchor', 'middle')
                .text('Percentage of Explicit Tracks (%)');

            svg.append('g')
                .call(d3.axisLeft(y))
                .selectAll('text')
                .style('font-size', '11px');
        }

        function createExplicitFeaturesChart() {
            const container = d3.select('#explicit-features-chart');
            const margin = {top: 20, right: 30, bottom: 60, left: 50};
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const features = ['energy', 'danceability', 'valence', 'speechiness'];
            const explicitTracks = spotifyData.filter(d => d.explicit);
            const cleanTracks = spotifyData.filter(d => !d.explicit);

            const data = features.map(feature => ({
                feature,
                explicit: d3.mean(explicitTracks, d => d[feature]),
                clean: d3.mean(cleanTracks, d => d[feature])
            }));

            const x0 = d3.scaleBand()
                .domain(data.map(d => d.feature))
                .range([0, width])
                .padding(0.1);

            const x1 = d3.scaleBand()
                .domain(['explicit', 'clean'])
                .range([0, x0.bandwidth()])
                .padding(0.05);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => Math.max(d.explicit, d.clean))])
                .range([height, 0]);

            const color = d3.scaleOrdinal()
                .domain(['explicit', 'clean'])
                .range([colors.secondary, colors.primary]);

            const tooltip = createTooltip();

            // Add grouped bars
            const featureGroups = svg.selectAll('.feature-group')
                .data(data)
                .enter().append('g')
                .attr('class', 'feature-group')
                .attr('transform', d => `translate(${x0(d.feature)},0)`);

            featureGroups.selectAll('rect')
                .data(d => [
                    { type: 'explicit', value: d.explicit, feature: d.feature },
                    { type: 'clean', value: d.clean, feature: d.feature }
                ])
                .enter().append('rect')
                .attr('x', d => x1(d.type))
                .attr('width', x1.bandwidth())
                .attr('y', d => y(d.value))
                .attr('height', d => height - y(d.value))
                .attr('fill', d => color(d.type))
                .on('mouseover', function(event, d) {
                    showTooltip(tooltip, `
                        <strong>${d.type} tracks</strong><br/>
                        ${d.feature}: ${d.value.toFixed(3)}
                    `, event);
                })
                .on('mouseout', () => hideTooltip(tooltip));

            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x0))
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-45)');

            svg.append('g')
                .call(d3.axisLeft(y))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -35)
                .attr('x', -height / 2)
                .attr('fill', 'black')
                .style('text-anchor', 'middle')
                .text('Average Value');

            // Add legend
            const legend = svg.append('g')
                .attr('transform', `translate(${width - 100}, 20)`);

            const legendData = [{ type: 'explicit', color: colors.secondary }, { type: 'clean', color: colors.primary }];

            legend.selectAll('.legend-item')
                .data(legendData)
                .enter().append('g')
                .attr('class', 'legend-item')
                .attr('transform', (d, i) => `translate(0, ${i * 20})`)
                .each(function(d) {
                    const g = d3.select(this);
                    g.append('rect')
                        .attr('width', 15)
                        .attr('height', 15)
                        .attr('fill', d.color);
                    g.append('text')
                        .attr('x', 20)
                        .attr('y', 12)
                        .style('font-size', '12px')
                        .text(d.type);
                });
        }

        // Event listeners
        d3.select('#artist-selector').on('change', function() {
            const selectedArtist = this.value;
            if (selectedArtist) {
                updateRadarChart(selectedArtist);
            }
        });

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                // Data will be loaded via fetch
            });
        } else {
            // DOM is already ready, data will be loaded via fetch
        }
    </script>
</body>
</html>